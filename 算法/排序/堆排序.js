// 堆排序的基本思想是：
// 1、将带排序的序列构造成一个大顶堆，根据大顶堆的性质，当前堆的根节点（堆顶）就是序列中最大的元素；
// 2、将堆顶元素和最后一个元素交换，然后将剩下的节点重新构造成一个大顶堆；3、重复步骤2，
// 如此反复，从第一次构建大顶堆开始，每一次构建，我们都能获得一个序列的最大值，然后把它放到大顶堆的尾部。
// 最后，就得到一个有序的序列了。


// 对于大顶堆：arr[i] >= arr[2i + 1] && arr[i] >= arr[2i + 2]

// 对于小顶堆：arr[i] <= arr[2i + 1] && arr[i] <= arr[2i + 2]


// 有一个无序序列：a=[4,5,8,2,3,9,7,1]
// 1、先构成一个大顶堆

// 将无序序列先看成一个无序无规则的二叉树 从上到下从左往右依次填到二叉树上

// 根据大顶堆的性质，每个节点的值都大于或者等于它的左右子节点的值。
// 所以我们需要找到所有包含子节点的节点，也就是非叶子节点，然后调整他们的父子关系，非叶子节点遍历的顺序应该是从下往上，
// 这比从上往下的顺序遍历次数少很多，因为，大顶堆的性质要求父节点的值要大于或者等于子节点的值，如果从上往下遍历，
// 当某个节点即是父节点又是子节点并且它的子节点仍然有子节点的时候，因为子节点还没有遍历到，所以子节点不符合大顶堆性质，
// 当子节点调整后，必然会影响其父节点需要二次调整。但是从下往上的方式不需要考虑父节点，因为当前节点调整完之后，
// 当前节点必然比它的所有子节点都大，所以，只会影响到子节点二次调整。相比之下，
// 从下往上的遍历方式比从上往下的方式少了父节点的二次调整。

// 2、所以这里选择使用从下到上的查找方式 先找到一个非叶子节点的节点来判断左右子节点是否符合堆排序的性质

// 那么，该如何知道最后一个非叶子节点的位置，也就是索引值？
// 对于一个完全二叉树，在填满的情况下（非叶子节点都有两个子节点），每一层的元素个数是上一层的二倍，根节点数量是1，
// 所以最后一层的节点数量，一定是之前所有层节点总数+1，
// 所以，我们能找到最后一层的第一个节点的索引，即节点总数/2（根节点索引为0），这也就是第一个叶子节点，
// 所以第一个非叶子节点的索引就是第一个叶子结点的索引-1。那么对于填不满的二叉树呢？这个计算方式仍然适用，
// 当我们从上往下，从左往右填充二叉树的过程中，第一个叶子节点，一定是序列长度/2，
// 所以第一个非叶子节点的索引就是arr.length / 2 -1。

// 总结：满二叉树和非满二叉树的第一个叶子节点是 arr.length / 2 所以非叶子节点的索引就是 arr.length / 2 - 1

// 3、也就说 从 [0 --> (arr.length / 2 - 1)] 的长度都是非叶子节点
// a=[4,5,8,2,3,9,7,1] 那么 就是 [4,5,8,2] 都是非叶子节点了

// 也就是从 2 开始先去比较 子节点是否大于 2 
// 然后 再比较 8 的子节点是否大于 8 这里可以看到 8 的子节点是 9， 7 那么较大的值 9 会替换 8 的位置
// 然后再去比较 5 的
// 比较 4 的 发现 4 的子节点是 5， 9  那么较大的值 9 会替换 4 的位置
// 然后将最大的 9 放到最后一个 再依次继续这样的比较

// 时间复杂度是 O(nlogn)
// 空间复杂度是 O(1)

// 参考：https://blog.csdn.net/qq_28063811/article/details/93034625/

function main(arr){
  create(arr);
  // 最大值和最后一个值做交换

  for(let i = arr.length -1; i>0; i--){
    [arr[i], arr[0]] = [arr[0], arr[i]];
    adjust(arr, 0, i)
  }

  return arr
}

// 构建大顶堆， 从第一个非叶子节点开始，进行下沉操作
function create(arr){
  const len = arr.length;
  const start = Math.floor(len/2) - 1;
  // 找到非叶子节点的元素然后调用这个函数
  for(let i=start; i>=0; i--){
    adjust(arr, i, len)
  } 
}

function adjust(arr, target, len){
  for(let i = 2 * target +1; i < len; i = 2 * i +1){
    // 找到孩子节点中的最大值
    if(i+1<len && arr[i+1]>arr[i]){
      i = i+1;
    }

    if(arr[i]>arr[target]){
      [arr[i], arr[target]]=[arr[target], arr[i]];
      // 一直去比较
      target = i;
    }else{
      break;
    }
  }
}

let a = [4,5,8,2,3,9,7,1]
console.log(main(a))